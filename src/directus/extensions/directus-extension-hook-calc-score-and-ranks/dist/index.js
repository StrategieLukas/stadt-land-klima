"use strict";console.log("Extension read");module.exports=({action:e,filter:a},{services:t,database:i,getSchema:n,logger:r})=>{r.info("Entering hook");const o={admin:!0},s=async()=>{const e="\n      BEGIN;\n      SELECT FROM public.municipalities ORDER BY id FOR UPDATE;\n      WITH RankedScores AS (\n        SELECT id, DENSE_RANK() OVER (ORDER BY score_total DESC) AS place\n        FROM public.municipalities\n        WHERE status='published'\n      )\n      UPDATE public.municipalities AS m\n      SET place = CASE WHEN m.status='published'\n        THEN (SELECT r.place FROM RankedScores r WHERE r.id=m.id)\n        ELSE -1\n      END;\n      COMMIT;\n    ";r.info(e),await i.raw(e)},c=async({keys:e=null,measureIds:a=null}={})=>{const i=await n(),s=new t.ItemsService("ratings_measures",{schema:i,accountability:o}),c=new t.ItemsService("measures",{schema:i,accountability:o}),l=new t.ItemsService("municipalities",{schema:i,accountability:o}),u=new t.ItemsService("municipality_scores",{schema:i,accountability:o}),m=await c.readByQuery({limit:-1,filter:{status:{_eq:"published"},catalog_version:{isCurrentBackend:{_eq:!0}}}}),d=m?.data??[];r.info(`[CalcScores] Loaded ${d.length} measures`);let y=[];if(r.info({keys:e}),e&&e.length){const a=await s.readMany(e);y=a?.data??[]}else{const e=await s.readByQuery({limit:-1});y=e?.data??[]}r.info(`[CalcScores] Loaded ${y.length} ratings`);const g=[...new Set(y.map(e=>e.localteam_id).filter(Boolean))];if(!g.length)return void r.info("[CalcScores] No municipalities to process, exit.");const p=(await l.readByQuery({filter:{localteam_id:{_in:g}},limit:-1}))?.data??[];r.info(`[CalcScores] Processing ${p.length} municipalities`);const f=new Map(d.map(e=>[e.id,e])),_=[...new Set(d.map(e=>"object"==typeof e.catalog_version?e.catalog_version.id:e.catalog_version).filter(Boolean))];for(const e of p){const a=y.filter(a=>a.localteam_id===e.localteam_id);for(const t of _){const i={total:{numerator:0,denominator:0},numberOfRated:{numerator:0,denominator:0},agriculture:{numerator:0,denominator:0},buildings:{numerator:0,denominator:0},management:{numerator:0,denominator:0},energy:{numerator:0,denominator:0},industry:{numerator:0,denominator:0},transport:{numerator:0,denominator:0}};for(const e of a){const a=f.get(e.measure_id);if(!a)continue;if(("object"==typeof a.catalog_version?a.catalog_version.id:a.catalog_version)!==t)continue;const n=a.sector,r=a.weight??0;i.total.denominator+=r,i.numberOfRated.denominator+=r,i[n]?i[n].denominator+=r:i[n]={numerator:0,denominator:r},e.approved&&"published"===e.status&&(i.total.numerator+=e.rating*r,i.numberOfRated.numerator+=r,i[n]&&(i[n].numerator+=e.rating*r))}const n={municipality:e.id,catalog_version:t,score_total:i.total.denominator>0?i.total.numerator/i.total.denominator*100:null,percentage_rated:i.numberOfRated.denominator>0?i.numberOfRated.numerator/i.numberOfRated.denominator*100:null,score_agriculture:i.agriculture.denominator>0?i.agriculture.numerator/i.agriculture.denominator*100:null,score_buildings:i.buildings.denominator>0?i.buildings.numerator/i.buildings.denominator*100:null,score_management:i.management.denominator>0?i.management.numerator/i.management.denominator*100:null,score_energy:i.energy.denominator>0?i.energy.numerator/i.energy.denominator*100:null,score_industry:i.industry.denominator>0?i.industry.numerator/i.industry.denominator*100:null,score_transport:i.transport.denominator>0?i.transport.numerator/i.transport.denominator*100:null},o=await u.readByQuery({limit:1,filter:{municipality:{_eq:e.id},catalog_version:{_eq:t}}}),s=o?.data??[];if(s.length){const a=s[0];await u.updateOne(a.id,n),r.info(`[CalcScores] Updated municipality_scores id=${a.id} mun=${e.id} cv=${t} → ${JSON.stringify(n)}`)}else r.warn(`[CalcScores] No municipality_scores found for mun=${e.id}, cv=${t}. Skipping update.`)}}},l=async(e,a)=>{const i=await n(),s=new t.ItemsService("municipalities",{schema:i,accountability:o}),c=new t.ItemsService("ratings_measures",{schema:i,accountability:o});new t.ItemsService("measures",{schema:i,accountability:o});const l=await s.readByQuery({limit:-1}),u=l?.data??[];for(const t of u){const i={measure_id:e,catalog_version:a,localteam_id:t.localteam_id,status:"draft",approved:!1,rating:null};await c.createOne(i),r.info(`[SeedRatings] Created rating stub for measure=${e}, mun=${t.localteam_id}, cv=${a}`)}};r.info("Registering actions/hooks"),e("items.create",async(e,a)=>{if("municipalities"!==e.collection)return;r.info("[Hook] municipalities.create triggered — creating initial scores");const i=await n(),s=new t.ItemsService("measure_catalog",{schema:i,accountability:o}),c=new t.ItemsService("municipality_scores",{schema:i,accountability:o}),l=Array.isArray(e.key)?e.key[0]:e.key,u=new t.ItemsService("municipalities",{schema:i,accountability:o}),m=await u.readOne(l);if(!m)return void r.warn(`[Hook] municipalities.create: municipality id=${l} not found`);const d=await s.readByQuery({limit:-1}),y=[];for(const e of d){const a={municipality:m.id,catalog_version:e.id,score_total:0,percentage_rated:0,score_agriculture:0,score_buildings:0,score_management:0,score_energy:0,score_industry:0,score_transport:0};r.info(a);const t=await c.createOne(a);y.push(t),r.info(`[Hook] Created empty municipality_scores for mun=${m.name}, measureCatalog=${e.name}`)}await u.updateOne(m.id,{scores:y}),r.info(`[Hook] Linked municipality.id=${m.id} to scores ids=${y}`)}),e("items.create",async(e,a)=>{if("measures"!==e.collection)return;const i=await n(),s=new t.ItemsService("measures",{schema:i,accountability:o}),c=Array.isArray(e.keys)?e.keys[0]:e.keys,u=await s.readOne(c);if(u&&"published"===u.status){const e="object"==typeof u.catalog_version?u.catalog_version.id:u.catalog_version;r.info(`[Hook] measures.create published → seeding ratings for measure=${c}, cv=${e}`),await l(c,e)}}),e("items.update",async(e,a)=>{if("measures"!==e.collection)return;const i=await n(),s=new t.ItemsService("measures",{schema:i,accountability:o}),c=Array.isArray(e.keys)?e.keys[0]:e.keys,u=await s.readOne(c);if(u&&e.payload&&"published"===e.payload.status){const e="object"==typeof u.catalog_version?u.catalog_version.id:u.catalog_version;r.info(`[Hook] measures.update → status published for measure=${c}, cv=${e}`),await l(c,e)}}),e("items.create",async(e,a)=>{"ratings_measures"===e.collection&&(r.info("[Hook] ratings_measures.create triggered"),await c({keys:e.keys}),await s())}),e("items.update",async(e,a)=>{"ratings_measures"===e.collection&&(r.info("[Hook] ratings_measures.update triggered"),await c({keys:e.keys}),await s())}),a("items.delete",async(e,a)=>{if("measures"!==e.collection)return e;const i=await n(),r=new t.ItemsService("ratings_measures",{schema:i,accountability:o});for(const a of e.keys){const e=await r.readByQuery({filter:{measure_id:{_eq:a},status:{_eq:"published"}},limit:1});if((e?.data??[]).length){const e=new Error(`Cannot delete measure ${a}: published ratings exist.`);throw e.code="FORBIDDEN",e}await r.deleteByQuery({filter:{measure_id:{_eq:a}}})}return e})};
